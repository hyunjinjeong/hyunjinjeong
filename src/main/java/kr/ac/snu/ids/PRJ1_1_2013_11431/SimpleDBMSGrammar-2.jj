// TODO:// 0. Reduce the number of lookahead in predicate()// 1. Modify the structure for printing.// 2. Disable user prompt on output results. (Optional)// 3. Process queries only on ';' character. (Optional)options{  STATIC = true;  IGNORE_CASE = true;}PARSER_BEGIN(SimpleDBMSParser)package kr.ac.snu.ids.PRJ1_1_2013_11431;public class SimpleDBMSParser{  public static final int PRINT_SYNTAX_ERROR = 0;
  public static final int PRINT_CREATE_TABLE = 1;
  public static final int PRINT_DROP_TABLE = 2;  public static final int PRINT_DESC = 3;  public static final int PRINT_SELECT = 4;  public static final int PRINT_INSERT = 5;  public static final int PRINT_DELETE = 6;  public static final int PRINT_SHOW_TABLES = 7;
      public static void main(String args[]) throws ParseException  {    SimpleDBMSParser parser = new SimpleDBMSParser(System.in);    printPrompt();    while (true)    {      try      {
        parser.command();      }      catch (Exception e)      {//        System.out.println(e);
        printMessage(PRINT_SYNTAX_ERROR);        printPrompt();
        SimpleDBMSParser.ReInit(System.in);      }    }  }  public static void printMessage(int q)  {    switch(q)
    {
      case PRINT_SYNTAX_ERROR:
      	System.out.println("Syntax error");
      	break;
      case PRINT_CREATE_TABLE:
      	System.out.println("'CREATE TABLE' requested");
      	break;
      case PRINT_DROP_TABLE:      	System.out.println("'DROP TABLE' requested");      	break;      case PRINT_DESC:      	System.out.println("'DESC' requested");      	break;      case PRINT_SELECT:      	System.out.println("'SELECT' requested");      	break;      case PRINT_INSERT:      	System.out.println("'INSERT' requested");      	break;      case PRINT_DELETE:      	System.out.println("'DELETE' requested");      	break;      case PRINT_SHOW_TABLES:      	System.out.println("'SHOW TABLES' requested");      	break;
    }  //    printPrompt();
  }  public static void printPrompt()  {    System.out.print("DB_2013-11431> ");  }}PARSER_END(SimpleDBMSParser)/* According to the JavaCC's FAQ (https://javacc.github.io/javacc/faq.html#question-3.3),   there are three rules to identify the next token.   1. The regular expression must describe a prefix of the remaining input stream.   2. If more than one regular expression describes a prefix,      then a regular expression that describes the longest prefix of the input stream is used      (this is called the maximal munch rule).   3. If more than one regular expression describes the longest possible prefix,      then the regular expression that comes first in the .jj file is used.      That is, the earlier the tokens are declared, the higher their priority is.      Therefore, Keywords Tokens must be declared before LEGAL_IDENTIFIER in case of conflict.*/ SKIP : { " " | "\r" | "\t" | "\n" }// Keywords: The two-word tokens have been separated into the two tokens of one word. 	TOKEN :{  < EXIT : "exit" >| < INT : "int" >| < CHAR : "char" >| < DATE : "date" >| < CREATE : "create" >| < DROP : "drop" >| < SHOW : "show" >| < DESC : "desc" >| < SELECT : "select" >| < INSERT : "insert" >| < DELETE : "delete" >| < TABLE : "table" >| < TABLES : "tables" >| < NULL : "null" >| < PRIMARY : "primary" >| < FOREIGN : "foreign" >| < KEY : "key" >| < REFERENCES : "references" >| < AS : "as" >| < FROM : "from" >| < WHERE : "where" >| < OR : "or" >| < AND : "and" >| < NOT : "not" >| < IS : "is" >| < INTO : "into" >| < VALUES : "values" >}// Normal tokens.TOKEN :{  < SEMICOLON : ";" >| < LEFT_PAREN : "(" >| < RIGHT_PAREN : ")" >| < COMMA : "," >| < DOT : "." >| < UNDERSCORE : "_" >| < ASTERISK : "*" >| < SIGN : "+" | "-" >  | < INT_VALUE : (< SIGN >)? (< DIGIT >)+ >| < DIGIT : [ "0"-"9" ] >| < NNNN : < DIGIT > < DIGIT > < DIGIT > < DIGIT > >| < NN : < DIGIT > < DIGIT > >| < DATE_VALUE : < NNNN > "-" < NN > "-" < NN > >| < OPERATOR : "<=" | ">=" | "!=" | "<" | ">" | "=" >| < LEGAL_IDENTIFIER : < ALPHABET > (< ALPHABET > | < UNDERSCORE >)* >| < ALPHABET : [ "a"-"z", "A"-"Z" ] >| < CHAR_STRING : < QUOTE > (< NON_QUOTE_CHARACTER >)* < QUOTE > >| < QUOTE : "'" > | < NON_QUOTE_CHARACTER : < DIGIT > | < ALPHABET > | < NON_QUOTE_SPECIAL_CHARACTERS > | " " >| < NON_QUOTE_SPECIAL_CHARACTERS : "!" | "@" | "#" | "$" | "%" | "^" | "&" | "-"    | "{" | "}" | "[" | "]" | "~" | "`" | "+" | < ASTERISK > | < UNDERSCORE > | "="    | "\\" | < LEFT_PAREN > | < RIGHT_PAREN > | "<" | ">" | "?" | < COMMA > | < DOT >      | "\n" | "\t" | "\r" | ":" | < SEMICOLON > | "|" | "/" >}void command() :{}{  queryList()| (    (      < EXIT >      < SEMICOLON >    )    | < EOF >  )  {    System.exit(0);  }}void queryList() :{  int q;}{  (    q = query()    < SEMICOLON >    {      printMessage(q);    }  )+  {    printPrompt();  }}int query() :{  int q;}{  (    createTableQuery()    {      q = PRINT_CREATE_TABLE;    }  | dropTableQuery()    {  	  q = PRINT_DROP_TABLE;    }  | descQuery()    {      q = PRINT_DESC;    }  | selectQuery()    {      q = PRINT_SELECT;    }  | insertQuery()    {      q = PRINT_INSERT;    }  | deleteQuery()    {  	  q = PRINT_DELETE;    }   | showTablesQuery()    {  	  q = PRINT_SHOW_TABLES;    }   )   (    {      return q;    }  )}// CREATE TABLEvoid createTableQuery() :{}{  < CREATE >  < TABLE >  tableName()  tableElementList()}void tableElementList() :{}{  < LEFT_PAREN >  tableElement()  (    < COMMA >    tableElement()  )*  < RIGHT_PAREN >}void tableElement() :{}{  columnDefinition()| tableConstraintDefinition()}void columnDefinition() :{}{  columnName()  dataType()  (    < NOT >    < NULL >  )?}void tableConstraintDefinition() :{}{  primaryKeyConstraint()| referentialConstraint()}void primaryKeyConstraint() :{}{  < PRIMARY >  < KEY >  columnNameList()}void referentialConstraint() :{}{  < FOREIGN >  < KEY >  columnNameList()  < REFERENCES >  tableName()  columnNameList()}void columnNameList() :{}{  < LEFT_PAREN >  columnName()  (    < COMMA >    columnName()  )*  < RIGHT_PAREN >}void dataType() :{}{  < INT >| (    < CHAR >    < LEFT_PAREN >    < INT_VALUE >    < RIGHT_PAREN >  )| < DATE >}void tableName() :{}{  < LEGAL_IDENTIFIER >}void columnName() :{}{  < LEGAL_IDENTIFIER >}// DROP TABLE / DESC / SHOW TABLESvoid dropTableQuery() :{}{  < DROP >  < TABLE >  tableName()}void descQuery() :{}{  < DESC >  tableName()}void showTablesQuery() :{}{  < SHOW >  < TABLES >}// SELECTvoid selectQuery() :{}{  < SELECT >  selectList()  tableExpression()}void selectList() :{}{  < ASTERISK >| (  	selectedColumn()  	(  	  < COMMA >  	  selectedColumn()  	)*  )}void selectedColumn() :{}{  columnInTable()  (	< AS >	columnName()  )?}void period() :{}{  < DOT >}// Make a function for duplicate expressions. void columnInTable() :{}{  (    LOOKAHEAD(2)    tableName()    period()  )?  columnName()}void tableExpression() :{}{  fromClause()  (    whereClause()  )?}void fromClause() :{}{  < FROM >  tableReferenceList()}void tableReferenceList() :{}{  referedTable()  (    < COMMA >    referedTable()  )*}void referedTable() :{}{  tableName()  (    < AS >    tableName()  )?}void whereClause() :{}{  < WHERE >  booleanValueExpression()}void booleanValueExpression() :{}{  booleanTerm()  (    < OR >    booleanTerm()  )*}void booleanTerm() :{}{  booleanFactor()  (    < AND >    booleanFactor()  )*}void booleanFactor() :{}{  (    < NOT >  )?  booleanTest()}void booleanTest() :{}{  predicate()| parenthesizedBooleanExpression()}void parenthesizedBooleanExpression() :{}{  < LEFT_PAREN >  booleanValueExpression()  < RIGHT_PAREN >}void predicate() :{}{  /* comparisonPredicate() can be 'columnInTable() compOp() ...' and     nullPredicate() can become 'columnInTable() nullOperation()'      the maximum number of tokens in columnInTable() is three,     so 4 tokens should be lookaheaded to determine which token is consumed.     Also, since nested lookahead is not calculated, a lookahead of 4 has been used.     */  LOOKAHEAD(4)  comparisonPredicate()| nullPredicate()}void comparisonPredicate() :{}{  compOperand()  compOp()  compOperand()}void compOperand() :{}{  comparableValue()| columnInTable()}void compOp() :{}{  < OPERATOR >
}void comparableValue() :{}{  < INT_VALUE >| < CHAR_STRING >| < DATE_VALUE >}void nullPredicate() :{}{  columnInTable()  nullOperation()}void nullOperation() :{}{  < IS >  (    < NOT >  )?  < NULL >}// INSERT / DELETEvoid insertQuery() :{}{  < INSERT >  < INTO >  tableName()  insertColumnAndSource()}void insertColumnAndSource() :{}{  (    columnNameList()  )?  valueList()}void valueList() :{}{  < VALUES >  < LEFT_PAREN >  value()  (    < COMMA >    value()  )*  < RIGHT_PAREN >}void value() :{}{  < NULL >| comparableValue()}void deleteQuery() :{}{  < DELETE >  < FROM >  tableName()  (    whereClause()  )?}