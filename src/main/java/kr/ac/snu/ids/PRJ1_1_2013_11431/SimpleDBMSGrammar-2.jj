options
{
  IGNORE_CASE = true;
}

PARSER_BEGIN(SimpleDBMSParser)
package kr.ac.snu.ids.PRJ1_1_2013_11431;

import java.io.UnsupportedEncodingException;
import java.io.File;
import java.util.ArrayList;

import com.sleepycat.je.Database;
import com.sleepycat.je.DatabaseException;
import com.sleepycat.je.DatabaseConfig;
import com.sleepycat.je.DatabaseEntry;
import com.sleepycat.je.Cursor;
import com.sleepycat.je.LockMode;
import com.sleepycat.je.OperationStatus;
import com.sleepycat.je.Environment;
import com.sleepycat.je.EnvironmentConfig;

public class SimpleDBMSParser
{
  private static Schema schema;
  
  public static void main(String args[]) throws ParseException
  {
    schema = new Schema();
    
    // Project 1-1 Parser
    SimpleDBMSParser parser = new SimpleDBMSParser(System.in);
    Message.printPrompt();
    
    while (true)
    {
      try
      {
        parser.command();
      }
      catch (ParseException e)
      {
        String msg;
        if (e.currentToken != null) {
          msg = Message.getMessage(Message.SYNTAX_ERROR);
        }
        else {
          msg = e.getMessage();
        }
        Message.print(msg);
        SimpleDBMSParser.ReInit(System.in);
        Message.printPrompt();
      }
    }
  }
}

PARSER_END(SimpleDBMSParser)
 

SKIP : { < SPACE: " " > | <  TAB : "\t" > | < EOL : "\r\n" | "\n" | "\r" > }

/*
   According to the JavaCC's FAQ page (https://javacc.github.io/javacc/faq.html#question-3.3),
   there are three rules to identify the next token.
   1. The regular expression must describe a prefix of the remaining input stream.
   2. If more than one regular expression describes a prefix,
      then a regular expression that describes the longest prefix of the input stream is used
      (this is called the maximal munch rule).
   3. If more than one regular expression describes the longest possible prefix,
      then the regular expression that comes first in the .jj file is used.

      That is, the earlier the tokens are declared, the higher their priority is.
      Therefore, Keywords Tokens must be declared before LEGAL_IDENTIFIER in case of conflict.
*/


/*
   Keyword Tokens: The two-word tokens have been separated into the two tokens of one word.
*/
TOKEN :
{
  < EXIT : "exit" >
| < INT : "int" >
| < CHAR : "char" >
| < DATE : "date" >
| < CREATE : "create" >
| < DROP : "drop" >
| < SHOW : "show" >
| < DESC : "desc" >
| < SELECT : "select" >
| < INSERT : "insert" >
| < DELETE : "delete" >
| < TABLE : "table" >
| < TABLES : "tables" >
| < NULL : "null" >
| < PRIMARY : "primary" >
| < FOREIGN : "foreign" >
| < KEY : "key" >
| < REFERENCES : "references" >
| < AS : "as" >
| < FROM : "from" >
| < WHERE : "where" >
| < OR : "or" >
| < AND : "and" >
| < NOT : "not" >
| < IS : "is" >
| < INTO : "into" >
| < VALUES : "values" >
}   


/*
   Normal tokens
*/
TOKEN :
{
  < END : < SEMICOLON > (< SPACE > | < TAB >)* < EOL > > 
| < SEMICOLON : ";" >
| < ASTERISK : "*" >
| < LEFT_PAREN : "(">
| < RIGHT_PAREN : ")">
| < COMMA : ",">
| < DOT : ".">
| < INT_VALUE : (< SIGN >)? (< DIGIT >)+ >
| < DATE_VALUE : < NNNN > "-" < NN > "-" < NN > >
| < CHAR_STRING : < QUOTE > (< NON_QUOTE_CHARACTER >)* < QUOTE > >
| < OPERATOR : "<=" | ">=" | "!=" | "<" | ">" | "=" >
| < LEGAL_IDENTIFIER : < ALPHABET > (< ALPHABET > | < UNDERSCORE >)* >
| < #SIGN : "+" | "-" >  
| < #DIGIT : [ "0"-"9" ] >
| < #NNNN : < DIGIT > < DIGIT > < DIGIT > < DIGIT > >
| < #NN : < DIGIT > < DIGIT > >
| < #ALPHABET : [ "a"-"z", "A"-"Z" ] >
| < #UNDERSCORE : "_" >
| < #QUOTE : "'" > 
| < #NON_QUOTE_CHARACTER : < DIGIT > | < ALPHABET > | < NON_QUOTE_SPECIAL_CHARACTERS > | " " >
| < #NON_QUOTE_SPECIAL_CHARACTERS : "!" | "@" | "#" | "$" | "%" | "^" | "&" | "-" | "{" | "}"
    | "[" | "]" | "~" | "`" | "+" | "*" | "_" | "=" | "\\" | "(" | ")" | "<" | ">" | "?" | "," | "."  
    | "\n" | "\t" | "\r" | ":" | ";" | "|" | "/" >
| < UNEXPECTED: ~[] >
}


void command() :
{}
{
  queryList()
| (
    (
      < EXIT >
      (
        < SEMICOLON > | < END >
      )
    )
  | < EOF >
  )
  {
    // Close DB
    schema.closeDatabase();
    System.exit(0);
  }
}

void queryList() :
{
  String msg;
}
{
  ( 
    msg = query()
    (
      (
        // When a query ends at the end.
        < END >
        {
          Message.print(msg);
          Message.printPrompt();
        }
      )
    | (
        // For query sequences. 
        < SEMICOLON >
        {
          Message.print(msg);
        }
      )
    )
  )+
}

String query() :
{
  String msg;
  String tableName;
}
{
  (
    createTableQuery()
    {
      msg = Message.getMessage(Message.CREATE_TABLE);
    }
  | tableName = dropTableQuery()
    {
      if (!(schema.tableExists(tableName))) {
        msg = Message.getMessage(Message.NO_SUCH_TABLE);
      }
      else {
        Table table = schema.getTable(tableName);
        if (table.isReferenced()) {
          throw new ParseException(Message.getMessage(Message.DROP_REFERENCED_TABLE_ERROR, tableName));
        }
        schema.dropTable(table);
        msg = Message.getMessage(Message.DROP_SUCCESS, tableName);
      }
    }
  | tableName = descQuery()
    {
      if (!(schema.tableExists(tableName))) {
        msg = Message.getMessage(Message.NO_SUCH_TABLE);
      }
      else { 
        Table table = schema.getTable(tableName);
        msg = table.toString();
      }
    }
  | selectQuery()
    {
      msg = Message.getMessage(Message.SELECT);
    }
  | insertQuery()
    {
      msg = Message.getMessage(Message.INSERT);
    }
  | deleteQuery()
    {
      msg = Message.getMessage(Message.DELETE);
    } 
  | showTablesQuery()
    {
      if (schema.isEmpty()) {
        msg = Message.getMessage(Message.SHOW_TABLES_NO_TABLE);
      }
      else { 
        msg = schema.getAllTableNames();
      }
    } 
  ) 
  (
    {
      return msg;
    }
  )
}

/*
   CREATE TABLE START
*/
void createTableQuery() :
{
  String name;
  Table table;
}
{
  < CREATE >
  < TABLE >
  name = tableName()
  {
    if (schema.tableExists(name)) {
      throw new ParseException(Message.getMessage(Message.TABLE_EXISTENCE_ERROR));
    }
    table = new Table(name);
  }
  tableElementList(table)
  {
    schema.createTable(table);
  }
}

void tableElementList(Table t) :
{}
{
  < LEFT_PAREN >
  tableElement(t)
  (
    < COMMA >
    tableElement(t)
  )*
  < RIGHT_PAREN >
}

void tableElement(Table t) :
{}
{
  columnDefinition(t)
| tableConstraintDefinition(t)
}

void columnDefinition(Table t) :
{
  String name;
  String type;
  Column c;
}
{
  name = columnName()
  {
    if (t.columnExists(name)) {
      throw new ParseException(Message.getMessage(Message.DUPLICATE_COLUMN_DEF_ERROR));
    }
    c = new Column(name, t.getName());
    t.addColumn(c);
  }
  type = dataType()
  {
    c.setType(type);
  }
  (
    < NOT >
    < NULL >
    {
      c.setNotNull();
    }
  )?
}

void tableConstraintDefinition(Table t) :
{}
{
  primaryKeyConstraint(t)
| referentialConstraint(t)
}

void primaryKeyConstraint(Table t) :
{
  ArrayList<String> columnNameList;
}
{
  < PRIMARY >
  < KEY >
  columnNameList = columnNameList()
  {
    for (String columnName: columnNameList) {
      if (!(t.columnExists(columnName))) {
        throw new ParseException(Message.getMessage(Message.NON_EXISTING_COLUMN_ERROR, columnName)); 
      }
      Column c = t.getColumn(columnName);
      if (t.primaryKeyExists(c)) {
        throw new ParseException(Message.getMessage(Message.DUPLICATE_PRIMARY_KEY_ERROR));
      }
      t.addPrimaryKey(c);
    }
  }
}

void referentialConstraint(Table t) :
{
  ArrayList<String> referencing;
  ArrayList<String> referenced;
  String tableName;
}
{
  < FOREIGN >
  < KEY >
  referencing = columnNameList()
  {
    ArrayList<Column> referencingList = new ArrayList<Column>();
    for (String columnName: referencing) {
      if (!(t.columnExists(columnName))) {
        throw new ParseException(Message.getMessage(Message.NON_EXISTING_COLUMN_ERROR, columnName)); 
      }
      referencingList.add(t.getColumn(columnName));
    }
  }
  < REFERENCES >
  tableName = tableName()
  {
    if (!(schema.tableExists(tableName))) {
      throw new ParseException(Message.getMessage(Message.REFERENCE_TABLE_EXISTENCE_ERROR));
    }
    Table referencedTable = schema.getTable(tableName);
  }
  referenced = columnNameList()
  {
    ArrayList<Column> referencedList = new ArrayList<Column>();
    for (String columnName: referenced) {
      if (!(referencedTable.columnExists(columnName))) {
        throw new ParseException(Message.getMessage(Message.REFERENCE_COLUMN_EXISTENCE_ERROR)); 
      }
      referencedList.add(referencedTable.getColumn(columnName));
    }
    if (referencingList.size() != referencedList.size()) {
      throw new ParseException(Message.getMessage(Message.REFERENCE_TYPE_ERROR));
    }
    
    if (!(schema.isValidForeignKeys(referencedList, referencedTable))) {
      throw new ParseException(Message.getMessage(Message.REFERENCE_NON_PRIMARY_KEY_ERROR));
    }

    
  }
}

ArrayList<String> columnNameList() :
{
  String name;
  ArrayList<String> columnList;
}
{
  {
    columnList = new ArrayList<String>();
  }
  < LEFT_PAREN >
  name = columnName()
  {
    columnList.add(name);
  }
  (
    < COMMA >
    name = columnName()
    {
      columnList.add(name);
    }
  )*
  < RIGHT_PAREN >
  {
    return columnList;
  }
}

String dataType() :
{
  String type;
  Token lengthToken;
  int intLength;
}
{
  (
    < INT >
    {
      type = Column.typeToAssign(Column.IntType);
    }
  | (
      < CHAR >
      < LEFT_PAREN >
      lengthToken = < INT_VALUE >
      < RIGHT_PAREN >
    )
    {
      intLength = Integer.parseInt(lengthToken.image);
      if (intLength < 1) {
        throw new ParseException(Message.getMessage(Message.CHAR_LENGTH_ERROR));
      }
      type = Column.typeToAssign(Column.CharType, intLength); 
    }
  | < DATE >
    {
      type = Column.typeToAssign(Column.DateType);
    }
  )
  {
    return type;
  }
}

String tableName() :
{}
{
  < LEGAL_IDENTIFIER >
  {
    return token.image.toLowerCase();
  }
}

String columnName() :
{}
{
  < LEGAL_IDENTIFIER >
  {
    return token.image.toLowerCase();
  }
}
/*
   CREATE TABLE END
*/

/*
   DROP TABLE / DESC / SHOW TABLES START
*/
String dropTableQuery() :
{
  String name;
}
{
  < DROP >
  < TABLE >
  name = tableName()
  {
    return name;
  }
}

String descQuery() :
{
  String name;
}
{
  < DESC >
  name = tableName()
  {
    return name;
  }
}

void showTablesQuery() :
{}
{
  < SHOW >
  < TABLES >
}
/*
   DROP TABLE / DESC / SHOW TABLES END
*/

/*
   SELECT START
*/
void selectQuery() :
{}
{
  < SELECT >
  selectList()
  tableExpression()
}

void selectList() :
{}
{
  < ASTERISK >
| (
    selectedColumn()
    (
      < COMMA >
      selectedColumn()
    )*
  )
}

void selectedColumn() :
{}
{
  columnInTable()
  (
    < AS >
    columnName()
  )?
}

void period() :
{}
{
  < DOT >
}

/*
   Make a new term for duplicate expressions.
   < COLUMN IN TABLE > ::= [< TABLE NAME > < PERIOD >] < COLUMN NAME >
*/ 
void columnInTable() :
{}
{
  (
    /*
       A lookahead of 2 is used here because both < TABLE NAME > and < COLUMN NAME > are < LEGAL IDENTIFIER >.
    */
    LOOKAHEAD(2)
    tableName()
    period()
  )?
  columnName()
}

void tableExpression() :
{}
{
  fromClause()
  (
    whereClause()
  )?
}

void fromClause() :
{}
{
  < FROM >
  tableReferenceList()
}

void tableReferenceList() :
{}
{
  referedTable()
  (
    < COMMA >
    referedTable()
  )*
}

void referedTable() :
{}
{
  tableName()
  (
    < AS >
    tableName()
  )?
}

void whereClause() :
{}
{
  < WHERE >
  booleanValueExpression()
}

void booleanValueExpression() :
{}
{
  booleanTerm()
  (
    < OR >
    booleanTerm()
  )*
}

void booleanTerm() :
{}
{
  booleanFactor()
  (
    < AND >
    booleanFactor()
  )*
}

void booleanFactor() :
{}
{
  (
    < NOT >
  )?
  booleanTest()
}

void booleanTest() :
{}
{
  predicate()
| parenthesizedBooleanExpression()
}

void parenthesizedBooleanExpression() :
{}
{
  < LEFT_PAREN >
  booleanValueExpression()
  < RIGHT_PAREN >
}

void predicate() :
{}
{
  /*
     comparisonPredicate() can be 'columnInTable() compOp() ...' and
     nullPredicate() can also become 'columnInTable() nullOperation()'. 
     Since the maximum number of tokens in columnInTable() is three,
     four tokens should be lookaheaded to determine which tokens are consumed.
     But a lookahead of 4 makes the parser much slower, so I have rewritten the grammar as below.
     <PREDICATE> ::= <COLUMN IN TABLE PREDICATE> | <COMPARABLE VALUE PREDICATE>
     <COLUMN IN TABLE PREDICATE> ::= <COLUMN IN TABLE> (<COMP OP> <COMP OPERAND> | <NULL OPERATION>)
     <COMPARABLE VALUE PREDICATE> ::= <COMPARABLE VALUE> <COMP OP> <COMP OPERAND>    
  */
  columnInTablePredicate()
| comparableValuePredicate()
}

void columnInTablePredicate() :
{}
{
  columnInTable()
  (
    (
      compOp()
      compOperand()
    )
    | nullOperation() 
  )
}

void comparableValuePredicate() :
{}
{
  comparableValue()
  compOp()
  compOperand()
}

void compOperand() :
{}
{
  comparableValue()
| columnInTable()
}

void compOp() :
{}
{
  < OPERATOR >
}

void comparableValue() :
{}
{
  < INT_VALUE >
| < CHAR_STRING >
| < DATE_VALUE >
}

void nullOperation() :
{}
{
  < IS >
  (
    < NOT >
  )?
  < NULL >
}
/*
   SELECT END
*/

/*
   INSERT / DELETE START
*/
void insertQuery() :
{}
{
  < INSERT >
  < INTO >
  tableName()
  insertColumnAndSource()
}

void insertColumnAndSource() :
{}
{
  (
    columnNameList()
  )?
  valueList()
}

void valueList() :
{}
{
  < VALUES >
  < LEFT_PAREN >
  value()
  (
    < COMMA >
    value()
  )*
  < RIGHT_PAREN >
}

void value() :
{}
{
  < NULL >
| comparableValue()
}

void deleteQuery() :
{}
{
  < DELETE >
  < FROM >
  tableName()
  (
    whereClause()
  )?
}
/*
   INSERT / DELETE END
*/